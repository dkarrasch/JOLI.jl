## joKron ##

##################
## type definition

export joKron, joKronException

immutable joKron <: joOp
    name::String
    e::DataType
    m::Integer
    n::Integer
    l::Integer
    ms::Array{Integer,1}
    ns::Array{Integer,1}
    #linop::Array{joOp,1}
    linop
end
function joKron(ops...)
    isa(ops,Tuple{Vararg{joOp}}) || throw(joKronException("Unnown operator types"))
    #println(typeof(ops))
    #println(length(ops))
    e=eltype(ops[1])
    m=1
    n=1
    l=length(ops)
    ms=Array{Integer}(0)
    ns=Array{Integer}(0)
    kops=Array{joOp}(0)
    for i=1:l
        #show(ops[i])
        e=promote_type(e,eltype(ops[i]))
        m*=ops[i].m
        push!(ms,ops[i].m)
        n*=ops[i].n
        push!(ns,ops[i].n)
        push!(kops,ops[i])
    end
    return joKron("joKron",e,m,n,l,ms,ns,kops)
end

type joKronException <: Exception
    msg :: String
end

##########################
## overloaded Base methods

function ctranspose(A::joKron)

    e=A.e
    m=A.n
    n=A.m
    l=A.l
    ms=A.ns
    ns=A.ms
    kops=Array{joOp}(0)
    for i=1:l
        push!(kops,A.linop[i]')
    end
    return joKron(A.name*"'",e,m,n,l,ms,ns,kops)

end

function *(A::joKron,v::AbstractVector)
    size(A, 2) == size(v, 1) || throw(joKronException("shape mismatch"))
    #println("A.ns:",A.ns)
    ksz=reverse(A.ns)
    #println("ksz:",ksz)
    V=reshape(v,ksz...)
    p=[x for x in 1:A.l]
    p=circshift(p,-1)
    #println("p:",p)
    for i=A.l:-1:1
        #println()
        #println(("before ksz",ksz))
        #println(("before sizes",size(A.linop[i]),size(V)))
        V=reshape(V,[ksz[1],prod(ksz[2:length(ksz)])]...)
        #println(("before sizes",size(A.linop[i]),size(V)))
        V=A.linop[i]*V
        ksz[1]=A.linop[i].m
        V=reshape(V,ksz...)
        #println(("after size",size(V)))
        V=permutedims(V,p)
        #println(("after size",size(V)))
        ksz=circshift(ksz,-1)
    end
    return vec(V)
end

